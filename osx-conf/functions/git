# vim: ft=sh sw=2 ts=2 expandtab

export GIT_PS1_SHOWCOLORHINTS=1
export GIT_PS1_SHOWDIRTYSTATE=1

git_default_branch() {
  local branch

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf '%s\n' "main"
    return 0
  fi

  branch="$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null || true)"
  if [[ -n "$branch" ]]; then
    printf '%s\n' "${branch#origin/}"
    return 0
  fi

  for branch in main master; do
    if git show-ref --verify --quiet "refs/heads/$branch" || git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
      printf '%s\n' "$branch"
      return 0
    fi
  done

  printf '%s\n' "main"
}

# fuzzy commit selecting
# Thanks to: https://github.com/christoomey/dotfiles/blob/77fb4084bd3f207aace80aa93a49769a6a298ddb/bin/git-shalector
git-shalector() {
  local target_commit
  target_commit="$(
    git log -75 --oneline --decorate --graph --all --color=always | \
    fzf --ansi --no-sort --reverse --tiebreak=index | \
    sed -E 's/.* ([0-9a-f]{7}) .*/\1/' | \
    tr -d '\n'
  )"

  printf '%s' "$target_commit" | pbcopy
  echo "Commit hash copied ($target_commit)"
}

delete_local_merged_branches() {
  local base branch
  base="$(git_default_branch)"

  git branch --merged "$base" | while IFS= read -r branch; do
    branch="${branch#\* }"
    branch="${branch# }"
    [[ -z "$branch" || "$branch" == "$base" ]] && continue
    git branch -d "$branch"
  done
}

delete_files_in_gitignore() {
  git ls-files -i --exclude-from=.gitignore | while IFS= read -r file; do
    [[ -n "$file" ]] && git rm --cached "$file"
  done
}

delete_remote_merged_branches() {
  local base remote_branch branch_name
  base="$(git_default_branch)"
  git fetch origin --prune

  git for-each-ref --format='%(refname:short)' "refs/remotes/origin" --merged "origin/$base" | while IFS= read -r remote_branch; do
    branch_name="${remote_branch#origin/}"
    [[ -z "$branch_name" || "$branch_name" == "HEAD" || "$branch_name" == "$base" ]] && continue
    git push origin --delete "$branch_name"
  done
}

minutes_since_last_commit() {
  local now last_commit seconds_since_last_commit minutes_since_last_commit
  now="$(date +%s)"
  last_commit="$(git log --pretty=format:'%at' -1 2>/dev/null)" || return
  seconds_since_last_commit=$((now - last_commit))
  minutes_since_last_commit=$((seconds_since_last_commit / 60))
  echo "$minutes_since_last_commit"
}

git_update_all() {
  local cur_dir repo_dir
  cur_dir="$(pwd)"

  echo "Pulling latest changes for all repositories..."
  find . -name ".git" -type d | while IFS= read -r repo_dir; do
    echo
    echo "$repo_dir"
    cd "${repo_dir%/.git}" || continue
    git pull
    cd "$cur_dir" || return 1
  done
  echo "Done."
}

git-author() {
  local args
  args=("$@")

  case "${1:-}" in
    set)
      export GIT_AUTHOR_NAME="${args[*]:1}"
      ;;
    unset)
      unset GIT_AUTHOR_NAME
      ;;
    show|get)
      echo "Current author: ${GIT_AUTHOR_NAME:-$(git config --get user.name)}"
      ;;
    *)
      echo "Usage git-author [set AUTHOR|unset|show|get]"
      git-author show
      ;;
  esac
}
